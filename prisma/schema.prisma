generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum Game {
  H1
  H2
  H3
  ODST
  REACH
  H4
}

enum Region {
  NA
  EU
  OCE
  SA
  AS
}

enum Platform {
  STEAM
}

enum Voice {
  MIC_REQUIRED
  MIC_OPTIONAL
  NO_MIC
}

enum Vibe {
  CASUAL
  SWEATY
  CHAOS
  RP
  OTHER
}

enum JoinRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum ReportTargetType {
  USER
  LOBBY
  REQUEST
}

enum ReportCategory {
  SPAM
  HARASSMENT
  IMPERSONATION
  OTHER
}

enum ReportStatus {
  OPEN
  RESOLVED
  DISMISSED
}

enum XpEventType {
  MESSAGE_SENT
  MESSAGE_REPLY
  FRIEND_ACCEPTED
  JOIN_REQUEST_CREATED
  JOIN_REQUEST_ACCEPTED
  HOST_LOBBY_CREATED
  LOBBY_ACTIVE_20_MIN
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum ConversationType {
  LOBBY
  DM
}

model User {
  id              String           @id @default(uuid())
  firebaseUid     String?          @unique
  email           String           @unique
  gamertag        String           @unique
  handle          String?          @unique
  displayName     String?
  nametagColor    String           @default("#FFFFFF")
  spartanImagePath String?
  favoriteGameId  String?
  favoriteWeaponId String?
  passwordHash    String
  steamName       String?
  needsGamertag   Boolean          @default(false)
  reputationScore Int              @default(0)
  xpTotal         Int              @default(0)
  srLevel         Int              @default(1)
  xpThisLevel     Int              @default(0)
  lastXpAt        DateTime?
  isBanned        Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  hostedLobbies   Lobby[]          @relation("HostLobbies")
  joinRequests    JoinRequest[]    @relation("RequesterJoinRequests")
  decisions       JoinRequest[]    @relation("DeciderJoinRequests")
  blocksInitiated Block[]          @relation("Blocker")
  blocksReceived  Block[]          @relation("Blocked")
  reportsFiled    Report[]         @relation("Reporter")
  reportsResolved Report[]         @relation("Resolver")
  rateLimitEvents RateLimitEvent[]
  lobbyMemberships LobbyMember[]
  xpEvents        XpEvent[]
  friendRequestsSent     FriendRequest[] @relation("FriendRequestFrom")
  friendRequestsReceived FriendRequest[] @relation("FriendRequestTo")
  friendshipsA           Friendship[]    @relation("FriendshipA")
  friendshipsB           Friendship[]    @relation("FriendshipB")
  conversationParticipants ConversationParticipant[]
  sentMessages             Message[]
  modPacks                 ModPack[]
}

model Lobby {
  id                     String       @id @default(uuid())
  hostUserId             String
  title                  String
  game                   Game
  mode                   String
  map                    String
  mapImageUrl            String?
  mapImagePath           String?
  region                 Region
  platform               Platform     @default(STEAM)
  voice                  Voice
  vibe                   Vibe
  tags                   String[]
  rulesNote              String
  friendsOnly            Boolean      @default(false)
  slotsTotal             Int          @default(16)
  slotsOpen              Int?
  isModded               Boolean      @default(true)
  workshopCollectionUrl  String?
  workshopItemUrls       String[]     @default([])
  requiresEacOff         Boolean      @default(true)
  modNotes               String?
  modPackId              String?
  isActive               Boolean      @default(true)
  lastHeartbeatAt        DateTime
  expiresAt              DateTime
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  host                   User         @relation("HostLobbies", fields: [hostUserId], references: [id], onDelete: Cascade)
  joinRequests           JoinRequest[]
  members                LobbyMember[]
  conversations          Conversation[]
  modPack                ModPack?     @relation(fields: [modPackId], references: [id], onDelete: SetNull)

  @@index([isActive, expiresAt, region, game, platform], map: "lobbies_browse_idx")
}

model Mod {
  id           String       @id @default(uuid())
  name         String
  workshopUrl  String       @unique
  workshopId   String?
  createdAt    DateTime     @default(now())
  modPackMods  ModPackMod[]
}

model ModPack {
  id           String       @id @default(uuid())
  name         String
  description  String?
  ownerUserId  String?
  isPublic     Boolean      @default(false)
  createdAt    DateTime     @default(now())
  owner        User?        @relation(fields: [ownerUserId], references: [id], onDelete: SetNull)
  modPackMods  ModPackMod[]
  lobbies      Lobby[]
}

model ModPackMod {
  id         String   @id @default(uuid())
  packId     String
  modId      String
  sortOrder  Int
  isOptional Boolean  @default(false)
  pack       ModPack  @relation(fields: [packId], references: [id], onDelete: Cascade)
  mod        Mod      @relation(fields: [modId], references: [id], onDelete: Cascade)

  @@unique([packId, modId], map: "mod_pack_mod_unique")
  @@index([packId, sortOrder], map: "mod_pack_mod_sort_idx")
}

model LobbyMember {
  id         String   @id @default(uuid())
  lobbyId    String
  userId     String
  slotNumber Int
  joinedAt   DateTime @default(now())
  lobby      Lobby    @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([lobbyId, userId], map: "lobby_members_unique_member")
  @@unique([lobbyId, slotNumber], map: "lobby_members_unique_slot")
}

model JoinRequest {
  id                   String            @id @default(uuid())
  lobbyId              String
  requesterUserId      String
  requesterPlatform    Platform        @default(STEAM)
  requesterHandleText  String
  note                 String?
  confirmedSubscribed  Boolean           @default(false)
  confirmedEacOff      Boolean           @default(false)
  status               JoinRequestStatus @default(PENDING)
  createdAt            DateTime          @default(now())
  decidedAt            DateTime?
  decidedByUserId      String?
  lobby                Lobby             @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  requester            User              @relation("RequesterJoinRequests", fields: [requesterUserId], references: [id], onDelete: Cascade)
  decidedBy            User?             @relation("DeciderJoinRequests", fields: [decidedByUserId], references: [id], onDelete: SetNull)

  @@index([lobbyId, status, createdAt], map: "join_requests_idx")
}

model Block {
  id            String   @id @default(uuid())
  blockerUserId String
  blockedUserId String
  reason        String?
  createdAt     DateTime @default(now())
  blocker       User     @relation("Blocker", fields: [blockerUserId], references: [id], onDelete: Cascade)
  blocked       User     @relation("Blocked", fields: [blockedUserId], references: [id], onDelete: Cascade)

  @@unique([blockerUserId, blockedUserId], map: "blocks_blocker_blocked_key")
}

model Report {
  id              String           @id @default(uuid())
  reporterUserId  String
  targetType      ReportTargetType
  targetId        String
  category        ReportCategory
  details         String
  status          ReportStatus     @default(OPEN)
  createdAt       DateTime         @default(now())
  resolvedAt      DateTime?
  resolvedByUserId String?
  reporter        User             @relation("Reporter", fields: [reporterUserId], references: [id], onDelete: Cascade)
  resolvedBy      User?            @relation("Resolver", fields: [resolvedByUserId], references: [id], onDelete: SetNull)
}

model RateLimitEvent {
  id        String   @id @default(uuid())
  userId    String
  key       String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, key, createdAt], map: "rate_limit_events_idx")
}

model XpEvent {
  id        String      @id @default(uuid())
  userId    String
  type      XpEventType
  amount    Int
  meta      Json?
  createdAt DateTime    @default(now())
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt], map: "xp_events_user_created_idx")
}

model FriendRequest {
  id        String             @id @default(uuid())
  fromUserId String
  toUserId   String
  status    FriendRequestStatus @default(PENDING)
  createdAt DateTime           @default(now())
  decidedAt DateTime?
  fromUser  User               @relation("FriendRequestFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser    User               @relation("FriendRequestTo", fields: [toUserId], references: [id], onDelete: Cascade)

  @@index([toUserId, status], map: "friend_requests_to_status_idx")
}

model Friendship {
  id        String   @id @default(uuid())
  userAId   String
  userBId   String
  createdAt DateTime @default(now())
  userA     User     @relation("FriendshipA", fields: [userAId], references: [id], onDelete: Cascade)
  userB     User     @relation("FriendshipB", fields: [userBId], references: [id], onDelete: Cascade)

  @@unique([userAId, userBId], map: "friendships_unique_pair")
}

model Conversation {
  id        String           @id @default(uuid())
  type      ConversationType
  lobbyId   String?
  createdAt DateTime         @default(now())
  lobby     Lobby?           @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  participants ConversationParticipant[]
  messages  Message[]

  @@unique([lobbyId], map: "conversation_lobby_unique")
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  userId         String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId], map: "conversation_participant_unique")
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  senderUserId   String
  body           String
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation(fields: [senderUserId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt], map: "messages_conversation_created_idx")
}
